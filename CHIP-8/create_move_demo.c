// 文件: create_move_demo.c
#include <stdio.h>
#include <stdint.h>

int main() {
    const char* filename = "move_demo.ch8";
    FILE* file = fopen(filename, "wb");
    if (!file) {
        perror("创建ROM文件失败");
        return 1;
    }

    // ============ CHIP-8程序：移动的像素点 ============
    // 键盘映射：
    // A(0x7)=左, D(0x9)=右, W(0x8)=上, S(0x5)=下
    // R(0xD)=重置到中心
    
    uint8_t program[] = {
        // === 初始化阶段 ===
        0x00, 0xE0,       // 0x0200: CLS              清屏
        0x60, 0x20,       // 0x0202: LD V0, 0x20     初始X=32(屏幕中心)
        0x61, 0x10,       // 0x0204: LD V1, 0x10     初始Y=16(屏幕中心)
        0x62, 0x01,       // 0x0206: LD V2, 0x01     移动速度=1像素/帧
        0x63, 0x00,       // 0x0208: LD V3, 0x00     上一帧按键状态（初始化）
        
        // === 主循环开始 ===
        // 1. 延迟控制（约30Hz，33ms/帧）
        0x64, 0x02,       // 0x020A: LD V4, 0x02     延迟计数器初始值
        0xF4, 0x15,       // 0x020C: LD DT, V4       设置延迟定时器=2
        // 等待延迟定时器归零
        0xF4, 0x07,       // 0x020E: LD V4, DT       读取延迟定时器
        0x34, 0x00,       // 0x0210: SE V4, 0x00     如果V4==0
        0x12, 0x0E,       // 0x0212: JP 0x020E       跳回等待（循环直到V4==0）
        
        // 2. 擦除旧位置像素（异或绘制同一位置即可擦除）
        0xA2, 0x50,       // 0x0214: LD I, 0x250     指向1x1像素精灵（后面定义）
        0xD0, 0x11,       // 0x0216: DRW V0, V1, 1   在(X,Y)绘制1像素（擦除）
        
        // 3. 检查方向键并更新位置
        // 检查A键(左移, 键码0x7)
        0x65, 0x07,       // 0x0218: LD V5, 0x07     设置要检查的键码=A
        0xF5, 0x0A,       // 0x021A: LD V5, K        等待按键（实际使用轮询）
        // 由于FX0A是阻塞的，这里我们用轮询模拟：EX9E/SKP
        0xE5, 0x9E,       // 0x021C: SKP V5          如果键A被按下
        0x12, 0x20,       // 0x021E: JP 0x0220       跳过减法（如果不按）
        0x80, 0x52,       // 0x0220: SUB V0, V2      V0 = V0 - V2 (X坐标减1)
        
        // 检查D键(右移, 键码0x9)
        0x65, 0x09,       // 0x0222: LD V5, 0x09     设置要检查的键码=D
        0xE5, 0x9E,       // 0x0224: SKP V5          如果键D被按下
        0x12, 0x28,       // 0x0226: JP 0x0228       跳过加法
        0x80, 0x24,       // 0x0228: ADD V0, V2      V0 = V0 + V2 (X坐标加1)
        
        // 检查W键(上移, 键码0x8)
        0x65, 0x08,       // 0x022A: LD V5, 0x08     设置要检查的键码=W
        0xE5, 0x9E,       // 0x022C: SKP V5          如果键W被按下
        0x12, 0x30,       // 0x022E: JP 0x0230       跳过减法
        0x81, 0x52,       // 0x0230: SUB V1, V2      V1 = V1 - V2 (Y坐标减1)
        
        // 检查S键(下移, 键码0x5)
        0x65, 0x05,       // 0x0232: LD V5, 0x05     设置要检查的键码=S
        0xE5, 0x9E,       // 0x0234: SKP V5          如果键S被按下
        0x12, 0x38,       // 0x0236: JP 0x0238       跳过加法
        0x81, 0x24,       // 0x0238: ADD V1, V2      V1 = V1 + V2 (Y坐标加1)
        
        // 检查R键(重置, 键码0xD)
        0x65, 0x0D,       // 0x023A: LD V5, 0x0D     设置要检查的键码=R
        0xE5, 0x9E,       // 0x023C: SKP V5          如果键R被按下
        0x12, 0x44,       // 0x023E: JP 0x0244       跳过重置
        0x60, 0x20,       // 0x0240: LD V0, 0x20     重置X=32
        0x61, 0x10,       // 0x0242: LD V1, 0x10     重置Y=16
        
        // 4. 边界检查（穿屏效果：从一边出去从另一边进来）
        // X坐标边界(0-63)
        0x45, 0x40,       // 0x0244: SNE V0, 0x40    如果V0 != 64 (0x40)
        0x12, 0x4A,       // 0x0246: JP 0x024A       跳过重置
        0x70, 0x01,       // 0x0248: ADD V0, 0x01    V0 = V0 + 1 (修正)
        0x46, 0xFF,       // 0x024A: SNE V0, 0xFF    如果V0 != 255
        0x12, 0x4E,       // 0x024C: JP 0x024E       跳过
        0x60, 0x00,       // 0x024E: LD V0, 0x00     如果X<0，则设为0
        
        // Y坐标边界(0-31)
        0x47, 0x20,       // 0x0250: SNE V1, 0x20    如果V1 != 32 (0x20)
        0x12, 0x56,       // 0x0252: JP 0x0256       跳过重置
        0x71, 0x01,       // 0x0254: ADD V1, 0x01    V1 = V1 + 1 (修正)
        0x48, 0xFF,       // 0x0256: SNE V1, 0xFF    如果V1 != 255
        0x12, 0x5A,       // 0x0258: JP 0x025A       跳过
        0x61, 0x00,       // 0x025A: LD V1, 0x00     如果Y<0，设为0
        
        // 5. 在新位置绘制像素
        0xA2, 0x50,       // 0x025C: LD I, 0x250     指向1x1像素精灵
        0xD0, 0x11,       // 0x025E: DRW V0, V1, 1   在(X,Y)绘制1像素
        
        // 6. 返回主循环开始
        0x12, 0x0A,       // 0x0260: JP 0x020A       跳回主循环开始
        
        // === 数据区：1x1像素精灵（1行，1像素点亮） ===
        // 内存地址0x250开始
        0x80,             // 0x0250: 二进制10000000（最左边的像素点亮）
        
        // 程序结束
    };

    // 写入程序
    size_t written = fwrite(program, 1, sizeof(program), file);
    fclose(file);
    
    if (written == sizeof(program)) {
        printf("? 成功创建移动像素演示ROM: %s\n", filename);
        printf("? 大小: %zu 字节\n", sizeof(program));
        printf("? 控制说明：\n");
        printf("   W(↑) - 上移\n");
        printf("  A(←)S(↓)D(→) - 左/下/右移\n");
        printf("   R - 重置到中心\n");
        printf("   ESC - 退出程序\n");
        printf("? 像素位置寄存器：V0=X坐标, V1=Y坐标\n");
        printf("? 运行后按相应键测试，像素应移动\n");
        return 0;
    } else {
        printf("? 写入ROM文件失败\n");
        return 1;
    }
}